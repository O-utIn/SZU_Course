
# 1.绪论
## 基本概念和术语
数据分成三个层次：**数据**、**数据元素**、**数据项**：\
1.**数据**是对客观事物的符号表示，在计算机科学中是指所有能输入到计算机中并被计算机程序处理的符合的总称。\
\-数值型数据\
\-非数值型数据\
2.**数据元素**是数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理。\
\-数据元素又称为元素、结点、记录\
3.**数据对象（数据项**：具有独立含义的最小标识单位，是性质相同的数据元素的集合，是数据的一个子集。

结构是数据元素之间的关系\
\-空间位置关系\
\-相互作用和依赖关系\
**数据结构**是相互之间存在一种或多种特定关系的数据元素的集合\
数据结构的形式定义是一个二元组\
四种结构：\
\-**集合**\
\-**线性结构**\
\-**树形结构**\
\-**图状结构**或**网状结构**

### 数据结构分为逻辑结构和存储结构
结构定义中的“关系”描述的是数据元素之间的逻辑关系，称为**逻辑结构**\
\-线性结构，线性表（表、栈、队列、串等）\
\-非线性结构，树、图等\
数据结构在计算机中的表示（映像）称为数据的**物理结构**，又称**存储结构**。它包括数据元素的表示和关系的表示\
\-顺序存储表示（例如C语言中的一维数组）\
\-链接存储表示（例如C语言中的指针）\
\-索引存储表示\
\-散列存储表示

**数据类型**是与数据结构密切相关的一个概念，用于描述程序操作对象的特性。可以理解为数据类型是一个值的集合和定义在这个值集上的一组操作的总称。
\-如C语言中的整型变量(int)，其值集为某个区间上的整数，定义在其上的操作为+, -, ×, /等\
**抽象数据类型**（Abstract Data Type，简称ADT），是指一个数学模型以及定义在该模型上的一组操作。\
抽象数据类型 = 数据结构 + 定义在此数据结构上的一组操作\
ADT的形式定义，三元组表示:\
	（D，S，P）\
	D是数据对象\
	S是D上的关系集\
	P是对D的基本操作集\
 ADT的示例：\
![image](https://github.com/user-attachments/assets/a1ade538-9c43-47c7-a033-e968fb01a575)

### 算法
**算法**是对特定问题求解步骤的一种描述，是一有限长的操作序列\
算法特性\
**有穷性**：算法在执行有穷步后能结束\
**确定性**：每步定义都是确切的、无歧义的\
**可行性**：算法描述的操作都是可以通过已实现的基本运算经过有限次来实现的\
**输  入**：有0个或多个输入\
**输  出**：有一个或多个输出

算法要求\
**正确性**：满足具体问题的需求\
**可读性**：便于理解和修改\
**健壮性**：当输入数据非法时，也能适当反应\
**效率与低存储需求**\
\-效率高：执行时间少，时间复杂度\
\-空间省：执行中需要的最大存储空间要少，空间复杂度

### 时间复杂度
**时间复杂度**，衡量算法的时间效率，主要依据算法执行所需要的时间\
**事后统计法**：计算算法开始时间与完成时间差值\
**事前统计法**：依据算法选用何种策略及问题的规模n，是常用的方法

时间复杂度是问题规模n的函数f(n)，即：\
    T(n) = O(f(n))\
一般地，时间复杂度用算法中最深层循环内的语句中的原操作的重复执行次数表示

常见的时间复杂度有：\
常量阶、对数阶、线性阶、平方阶、立方阶、指数阶、排列阶\
 O(1) < O(log2n) < O(n) < O(n2) < O(n3) < O(2n) < O(n!)\
一般时间复杂度低于平方阶的算法视为高效率算法\
一般指数阶算法视为不可行算法，例如NP难题、NP完全问题多是指时间复杂度为指数阶或更高阶

时间复杂度并不唯一，因为算法的执行有多种可能的操作顺序\
当可以估算各种操作可能，一般计算**平均时间复杂度**\
如果无法计算平均时间复杂度，则采用**最坏情况下**的时间复杂度，又称**最坏时间复杂度**

**时间复杂度是衡量算法好坏的最重要标准**

### 空间复杂度
空间复杂度指算法执行时，所需要存储空间的量度，它也是问题规模的函数，即：\
　　　S(n) = O(f(n))，除输入和程序之外的额外空间\
一个程序运行需要的存储空间包括三部分：\
程序代码空间\
输入数据空间\
算法执行需要的辅助空间\
空间复杂度只考虑除输入和程序之外的额外空间\
空间复杂度只考虑辅助变量的额外空间

# 2.线性表
线性数据结构的特点\
**同一性**，同一个线性表的数据属同一类数据对象\
![image](https://github.com/user-attachments/assets/c697f3de-d7ee-4fab-97a8-ec27c455b5aa)


**顺序性**，数据之间存在序偶关系
数据顺序性
除第一个元素外，每个数据元素均只有一个直接前驱
除最后一个元素外，每个数据元素均只有一个直接后继(next)
没有直接前驱的元素即第一个数据元素
没有直接后继的元素即最后一个元素
![image](https://github.com/user-attachments/assets/e82734b0-3c02-463a-aa47-8930eea43f14)
![image](https://github.com/user-attachments/assets/46daec47-9ebb-4a75-a62e-7dfcfc612eaa)


## 线性表的顺序表示和实现：顺序表
![image](https://github.com/user-attachments/assets/973e761e-7f70-489f-860a-91a91ab78bcb)
![image](https://github.com/user-attachments/assets/ff3a1ddd-a0fa-4e18-a734-eef35502aa7d)

### 顺序表的优点：
元素位置可用一个简单、直观的公式表示并读写\
元素可以随机存取

### 顺序表的缺点：
在作插入或删除操作时，需要移动大量元素\
因此引入链表，减少操作

## 线性表的链式表示和实现：链表
![image](https://github.com/user-attachments/assets/4847df6e-081e-47c6-800c-b478f9c0ee5d)

单链表插入的时间复杂度主要取决于while循环中的语句频度\
循环频度与在链表中的元素位置查找有关，因此线性链表插入的时间复杂度为O(n)

### 单链表的删除：给出要删除的链表、删除位置
删除是把链表的第i-1元素与第i+1元素之间的第i元素删除\
链表的删除不需要移动元素，只需要修改指针\
单链表删除的时间复杂度主要取决于while循环中的语句频度\
循环频度与在链表中的元素位置查找有关，因此线性链表删除的时间复杂度为O(n)\

### 顺序表与链表的比较（空间）
存储分配的方式\
顺序表的存储空间是静态分配的\
链表的存储空间是动态分配的\
存储密度 = 结点数据本身所占的存储量/结点结构所占的存储总量\
顺序表的存储密度 = 1\
链表的存储密度 < 1

### 顺序表与链表的比较（时间）
存取方式\
顺序表可以随机存取，也可以顺序存取\
链表必须顺序存取\
插入/删除时移动元素个数\
顺序表平均需要移动近一半元素\
链表不需要移动元素，只需要修改指针
![image](https://github.com/user-attachments/assets/7eb276c5-74ab-469a-8a4c-4c4b1ae1c35a)
![image](https://github.com/user-attachments/assets/0fd203e3-04da-4f3f-b549-2c12d9541622)

# 3.栈和队列
## 栈的概念
栈是限定仅在表尾（top）进行插入或删除操作的线性表\
允许插入和删除的一端称为栈顶（top，表尾）\
栈的另一端称为栈底（bottom，表头）\
栈的特点，后进先出（LIFO,last in first out）
![image](https://github.com/user-attachments/assets/1f3e5413-81c3-4c4d-ae3b-e033d47ea0e0)

### 顺序栈
顺序栈是栈的一种顺序实现，是顺序存储结构，利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素
![image](https://github.com/user-attachments/assets/0d11d9eb-9c35-44be-bc0c-8d6b8e1706ed)
![image](https://github.com/user-attachments/assets/6bb59796-212b-4699-8539-ad1fbcfac2dc)

顺序栈的特性：\
top==0或top==base，表示空栈\
base=NULL表示栈不存在\
入栈，只能从栈顶插入，指针top++\
出栈，只能从栈顶删除，指针top--\
当top>stacksize时，栈满，溢出，又称“上溢”

### 链栈
链栈是栈的链式存储结构，是运算受限的单链表\
其插入和删除操作只能在表头位置上进行\
链栈用没有头结点的单链表，链表头指针表示栈顶指针top
![image](https://github.com/user-attachments/assets/4c886c12-8b75-425c-82fa-5997bebe56ad)
![image](https://github.com/user-attachments/assets/c9b9cf53-187f-48b6-b7bf-0862be9a6368)

**注意栈的后进先出操作，顺序栈不是数组**\
**顺序栈不能执行数组的遍历操作**

![image](https://github.com/user-attachments/assets/0006ea49-1583-4f8c-8b2d-f67d4a05a27f)
![image](https://github.com/user-attachments/assets/86c711b9-8ca8-43f2-b6c8-cb2d35d01d23)
\
\
共享栈的判栈满条件：\
![image](https://github.com/user-attachments/assets/c6bf9b74-6f29-4c33-a0fe-20ce596ff2a1)
![image](https://github.com/user-attachments/assets/ecf45910-8259-4b2a-a6d9-e4a5dc829c6a)


栈是限定操作的线性表，特点后进先出\
栈的出栈可能结果序列、入栈出栈操作序列\
顺序栈，理解top栈顶、base栈底\
插入、删除、取栈顶的操作，top的变化\
判栈空top==base\
链栈，采用头插法，top是一个指针，指向首结点\
共享栈，两个栈共用一个数组空间，两个栈顶相邻则栈满\
![image](https://github.com/user-attachments/assets/6df0ef3a-f9d8-42d8-9250-0d43594a8cdd)











